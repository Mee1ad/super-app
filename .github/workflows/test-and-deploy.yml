name: Test, Migrate, and Deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  test-and-migrate:
    name: Test Migrations and Run Tests
    runs-on: ubuntu-latest
    
    # Add PostgreSQL service container for testing
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U testuser"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
          
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-asyncio aiosqlite
        
    - name: Wait for PostgreSQL
      run: |
        echo "Waiting for PostgreSQL to be ready..."
        for i in {1..30}; do
          pg_isready -h localhost -p 5432 -U testuser && break
          echo "PostgreSQL not ready yet, waiting..."
          sleep 2
        done
        
    - name: Set test environment variables
      run: |
        echo "ENVIRONMENT=development" >> $GITHUB_ENV
        echo "DB_HOST=localhost" >> $GITHUB_ENV
        echo "DB_PORT=5432" >> $GITHUB_ENV
        echo "DB_NAME=testdb" >> $GITHUB_ENV
        echo "DB_USER=testuser" >> $GITHUB_ENV
        echo "DB_PASSWORD=testpass" >> $GITHUB_ENV
        echo "SECRET_KEY=test-secret-key" >> $GITHUB_ENV
        echo "DEBUG=false" >> $GITHUB_ENV
        
    - name: Test database migrations
      run: |
        echo "üß™ Testing database migrations on fresh PostgreSQL instance..."
        python db/migrate.py
        echo "‚úÖ Migrations completed successfully!"
        
    - name: Run unit tests
      run: |
        echo "üß™ Running unit tests..."
        pytest tests/unit/ -v --disable-warnings --tb=short
        
    - name: Run CORS tests
      run: |
        echo "üß™ Running CORS tests..."
        pytest tests/test_cors.py -v --disable-warnings --tb=short
        
    - name: Run integration tests
      run: |
        echo "üß™ Running integration tests against migrated database..."
        pytest tests/integration/ -v --disable-warnings --tb=short
        
    - name: Verify database state after tests
      run: |
        echo "üîç Verifying database state after all tests..."
        python -c "
import asyncio
import sys
import os
sys.path.append(os.path.dirname(os.path.abspath('.')))
from db.session import database
from core.config import settings

async def verify_database():
    try:
        await database.connect()
        # Check if tables exist
        result = await database.fetch_all(\"\"\"
            SELECT table_name 
            FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name IN ('lists', 'tasks', 'shopping_items')
            ORDER BY table_name;
        \"\"\")
        tables = [row[0] for row in result]
        print(f'‚úÖ Found tables: {tables}')
        
        # Check if migrations table exists
        result = await database.fetch_all(\"\"\"
            SELECT name FROM migrations ORDER BY applied_at;
        \"\"\")
        migrations = [row[0] for row in result]
        print(f'‚úÖ Applied migrations: {migrations}')
        
        await database.disconnect()
        print('‚úÖ Database verification successful!')
    except Exception as e:
        print(f'‚ùå Database verification failed: {e}')
        sys.exit(1)

asyncio.run(verify_database())
        "

  migrate-production:
    name: Run Production Migrations
    runs-on: ubuntu-latest
    needs: test-and-migrate
    if: success()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Run production database migrations
      run: |
        echo "üöÄ Running migrations on production database..."
        python db/migrate.py
        echo "‚úÖ Production migrations completed successfully!"
      env:
        DATABASE_URL: ${{ secrets.DATABASE_URL }}
        DB_HOST: ${{ secrets.DB_HOST }}
        DB_PORT: ${{ secrets.DB_PORT }}
        DB_NAME: ${{ secrets.DB_NAME }}
        DB_USER: ${{ secrets.DB_USER }}
        DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        
    - name: Verify production database connection
      run: |
        echo "üîç Verifying production database connection..."
        python -c "
import asyncio
import sys
import os
sys.path.append(os.path.dirname(os.path.abspath('.')))
from db.session import database
from core.config import settings

async def test_connection():
    try:
        await database.connect()
        result = await database.fetch_all('SELECT version();')
        print(f'‚úÖ Production database connection successful: {result[0][0]}')
        await database.disconnect()
    except Exception as e:
        print(f'‚ùå Production database connection failed: {e}')
        sys.exit(1)

asyncio.run(test_connection())
        "
      env:
        DATABASE_URL: ${{ secrets.DATABASE_URL }}
        DB_HOST: ${{ secrets.DB_HOST }}
        DB_PORT: ${{ secrets.DB_PORT }}
        DB_NAME: ${{ secrets.DB_NAME }}
        DB_USER: ${{ secrets.DB_USER }}
        DB_PASSWORD: ${{ secrets.DB_PASSWORD }}

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [test-and-migrate, migrate-production]
    if: success()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install Ansible
      run: |
        python -m pip install --upgrade pip
        pip install ansible
        
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/super-app-backend
        chmod 600 ~/.ssh/super-app-backend
        ssh-keyscan -H ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts
        
    - name: Create secrets directory
      run: mkdir -p secrets
      
    - name: Create secrets files
      run: |
        echo "${{ secrets.DB_PASSWORD }}" > secrets/db_password
        echo "${{ secrets.API_KEY }}" > secrets/api_key
        
    - name: Test SSH connection
      run: |
        ssh -i ~/.ssh/super-app-backend -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "echo 'SSH connection successful'"
        
    - name: Deploy with Ansible
      env:
        ANSIBLE_HOST_KEY_CHECKING: false
        SERVER_IP: ${{ secrets.SERVER_IP }}
        ANSIBLE_USER: ${{ secrets.SERVER_USER }}
        SSH_KEY_FILE: ~/.ssh/super-app-backend
        SSH_PUBLIC_KEY: ${{ secrets.SSH_PUBLIC_KEY }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_TOKEN: ${{ secrets.CR_PAT }}
        DB_HOST: ${{ secrets.DB_HOST }}
        DB_PORT: ${{ secrets.DB_PORT }}
        DB_NAME: ${{ secrets.DB_NAME }}
        DB_USER: ${{ secrets.DB_USER }}
        DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        SECRET_KEY: ${{ secrets.SECRET_KEY }}
        DEBUG: ${{ secrets.DEBUG }}
      run: |
        echo "üöÄ Starting deployment..."
        echo "Environment variables:"
        echo "SERVER_IP: $SERVER_IP"
        echo "ANSIBLE_USER: $ANSIBLE_USER"
        echo "GITHUB_REPOSITORY: $GITHUB_REPOSITORY"
        echo "DB_HOST: $DB_HOST"
        echo "DB_PORT: $DB_PORT"
        echo "DB_NAME: $DB_NAME"
        echo "DB_USER: $DB_USER"
        ansible-playbook -i ansible/inventory.yml ansible/deploy.yml -v
        
    - name: Verify deployment
      run: |
        echo "üîç Verifying deployment..."
        sleep 30  # Wait for container to start
        curl -f http://${{ secrets.SERVER_IP }}:8000/ping || echo "‚ö†Ô∏è  Health check failed, but deployment may still be successful" 