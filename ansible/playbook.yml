- hosts: web
  become: true
  vars_files:
    - group_vars/all.yml
    - group_vars/vault.yml
  vars:
    domain: api.todomodo.ir
  tasks:

    - name: Update system packages
      apt:
        update_cache: yes
        upgrade: dist
      tags: [system, update]

    - name: Create a new sudo user
      user:
        name: "{{ os_user }}"
        groups: sudo
        shell: /bin/bash
        state: present
        create_home: yes
      tags: [user]

    - name: Copy SSH public key to new user
      authorized_key:
        user: "{{ os_user }}"
        state: present
        key: "{{ lookup('file', lookup('env','HOME') + '/.ssh/super-app-backend.pub') }}"
      tags: [user, ssh]

    - name: Allow sudo without password
      lineinfile:
        dest: /etc/sudoers
        state: present
        regexp: '^{{ os_user }}'
        line: '{{ os_user }} ALL=(ALL) NOPASSWD:ALL'
      tags: [user]

#    - name: Harden SSH - disable root login
#      lineinfile:
#        path: /etc/ssh/sshd_config
#        regexp: '^#?PermitRootLogin'
#        line: 'PermitRootLogin no'
#      tags: [security, ssh]

    - name: Harden SSH - disable password auth
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?PasswordAuthentication'
        line: 'PasswordAuthentication no'
      tags: [security, ssh]

    - name: Restrict SSH access to new user
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?AllowUsers'
        line: 'AllowUsers {{ os_user }}'
      tags: [security, ssh]

    - name: Restart SSH service
      service:
        name: ssh
        state: restarted
      tags: [ssh]

    - name: Add Docker GPG key
      apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present
      tags: [packages, docker]

    - name: Add Docker APT repository
      apt_repository:
        repo: "deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
        state: present
        filename: docker
      tags: [packages, docker]

    - name: Update APT cache
      apt:
        update_cache: yes
      tags: [packages, docker]

    - name: Install required packages
      apt:
        name:
          - ufw
          - nginx
          - git
          - docker-ce
          - docker-ce-cli
          - containerd.io
          - docker-compose-plugin
          - fail2ban
          - logrotate
          - certbot
          - python3-certbot-nginx
        state: present
        update_cache: yes
      tags: [packages, docker, nginx, postgres, ssl]

    - name: Add user to docker group
      user:
        name: "{{ os_user }}"
        groups: docker
        append: yes
      tags: [ user ]

    - name: Add PostgreSQL APT repository key
      apt_key:
        url: https://www.postgresql.org/media/keys/ACCC4CF8.asc
        state: present
      tags: [packages, postgres]

    - name: Add PostgreSQL 16 repository
      apt_repository:
        repo: "deb http://apt.postgresql.org/pub/repos/apt {{ ansible_distribution_release }}-pgdg main"
        state: present
        filename: 'pgdg'
      tags: [packages, postgres]

    - name: Install PostgreSQL 16
      apt:
        name:
          - postgresql-16
          - postgresql-client-16
          - python3-psycopg2
        state: present
        update_cache: yes
      tags: [packages, postgres]

    - name: Change postgres password if it's different
      become: true
      become_user: postgres
      shell: |
        psql -tAc "SELECT 1 FROM pg_authid WHERE rolname='postgres' AND rolpassword = crypt('{{ postgres_password }}', rolpassword);" | grep -q 1 \
        || psql -c "ALTER USER postgres WITH PASSWORD '{{ postgres_password }}';"
      tags: [ postgres, db ]

    - name: Configure PostgreSQL to listen on all addresses
      lineinfile:
        path: /etc/postgresql/16/main/postgresql.conf
        regexp: '^#?listen_addresses'
        line: "listen_addresses = '*'"
      tags: [postgres, db]

    - name: Allow local network access in pg_hba.conf
      lineinfile:
        path: /etc/postgresql/16/main/pg_hba.conf
        insertafter: '^# IPv4 local connections:'
        line: "host    all             all             0.0.0.0/0               md5"
      tags: [postgres, db]

    - name: Restart PostgreSQL
      service:
        name: postgresql
        state: restarted
      tags: [postgres, db]

    - name: Enable Docker service
      systemd:
        name: docker
        enabled: yes
        state: started
      tags: [docker]

    - name: Clone Esmerald project
      git:
        repo: "{{ backend_repo }}"
        dest: "{{ backend_dir }}"
        version: main
      tags: [app, code]

    - name: Generate secret key if not exists
      command: "openssl rand -base64 48"
      register: generated_key
      changed_when: false
      when: secret_key is not defined
      tags: [env, update]

    - name: Set secret_key from generated key
      set_fact:
        secret_key: "{{ generated_key.stdout }}"
      when: secret_key is not defined
      tags: [env, update]

    - name: Render .env from template
      template:
        src: files/env.production.j2
        dest: "{{ backend_dir }}/.env"
        owner: "{{ os_user }}"
        group: "{{ os_user }}"
        mode: '0600'
      tags: [env, update]

    - name: Build and start containers
      shell: docker compose up -d --build
      args:
        chdir: "{{ backend_dir }}"
      tags: [app, docker]

    - name: Run initial DB migrations
      shell: docker compose exec api python db/migrate.py
      args:
        chdir: "{{ backend_dir }}"
      tags: [ app, db, migrate ]

    - name: Disable default nginx site
      file:
        path: /etc/nginx/sites-enabled/default
        state: absent
      tags: [nginx]

    - name: Add initial nginx config for SSL certificate
      copy:
        dest: /etc/nginx/sites-available/{{ domain }}
        content: |
          server {
              listen 80;
              server_name {{ domain }};
              
              location /.well-known/acme-challenge/ {
                  root /var/www/certbot;
              }
              
              location / {
                  return 301 https://$server_name$request_uri;
              }
          }
      tags: [nginx, ssl]

    - name: Enable initial nginx site
      file:
        src: /etc/nginx/sites-available/{{ domain }}
        dest: /etc/nginx/sites-enabled/{{ domain }}
        state: link
      tags: [nginx, ssl]

    - name: Create certbot webroot directory
      file:
        path: /var/www/certbot
        state: directory
        mode: '0755'
      tags: [ssl]

    - name: Restart nginx for initial config
      service:
        name: nginx
        state: restarted
      tags: [nginx, ssl]

    - name: Obtain SSL certificate
      command: certbot certonly --webroot -w /var/www/certbot -d {{ domain }} --email {{ certbot_email | default('admin@todomodo.ir') }} --agree-tos --non-interactive
      register: certbot_result
      failed_when: certbot_result.rc != 0 and 'already exists' not in certbot_result.stderr
      changed_when: certbot_result.rc == 0
      tags: [ssl]

    - name: Add SSL nginx config
      copy:
        dest: /etc/nginx/sites-available/{{ domain }}
        content: |
          # Redirect HTTP to HTTPS
          server {
              listen 80;
              server_name {{ domain }};
              return 301 https://$server_name$request_uri;
          }
          
          # HTTPS server
          server {
              listen 443 ssl http2;
              server_name {{ domain }};
              
              # SSL configuration
              ssl_certificate /etc/letsencrypt/live/{{ domain }}/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/{{ domain }}/privkey.pem;
              ssl_trusted_certificate /etc/letsencrypt/live/{{ domain }}/chain.pem;
              
              # SSL security settings
              ssl_protocols TLSv1.2 TLSv1.3;
              ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
              ssl_prefer_server_ciphers off;
              ssl_session_cache shared:SSL:10m;
              ssl_session_timeout 10m;
              
              # Security headers
              add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
              add_header X-Frame-Options DENY always;
              add_header X-Content-Type-Options nosniff always;
              add_header X-XSS-Protection "1; mode=block" always;
              add_header Referrer-Policy "strict-origin-when-cross-origin" always;
              
              # Proxy settings
              location / {
                  proxy_pass http://localhost:8000;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
                  
                  # WebSocket support
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection "upgrade";
                  
                  # Timeouts
                  proxy_connect_timeout 60s;
                  proxy_send_timeout 60s;
                  proxy_read_timeout 60s;
              }
              
              # Health check endpoint
              location /health {
                  access_log off;
                  return 200 "healthy\n";
                  add_header Content-Type text/plain;
              }
              
              # Let's Encrypt challenge
              location /.well-known/acme-challenge/ {
                  root /var/www/certbot;
              }
          }
      tags: [nginx, ssl]

    - name: Test nginx configuration
      command: nginx -t
      tags: [nginx, ssl]

    - name: Reload nginx after SSL config
      service:
        name: nginx
        state: reloaded
      tags: [nginx, ssl]

    - name: Setup SSL certificate renewal
      copy:
        dest: /etc/cron.d/certbot-renew
        content: |
          0 12 * * * root /usr/bin/certbot renew --quiet --deploy-hook "systemctl reload nginx"
        mode: '0644'
      tags: [ssl, cron]

    - name: Enable UFW firewall
      ufw:
        state: enabled
        policy: deny
      tags: [security, ufw]

    - name: Allow SSH, HTTP and HTTPS
      ufw:
        rule: allow
        port: "{{ item }}"
      loop:
        - 22
        - 80
        - 443
      tags: [security, ufw]

    - name: Setup daily PostgreSQL backup script
      copy:
        dest: /usr/local/bin/pg_backup.sh
        mode: '0750'
        content: |
          #!/bin/bash
          BACKUP_DIR="/var/backups/postgresql"
          mkdir -p "$BACKUP_DIR"
          pg_dumpall -U postgres | gzip > "$BACKUP_DIR/all_$(date +%F).sql.gz"
      tags: [postgres, backup]

    - name: Setup cron job for backup
      cron:
        name: "Daily PostgreSQL backup"
        job: "/usr/local/bin/pg_backup.sh"
        user: postgres
        hour: 2
        minute: 0
      tags: [postgres, backup]

    - name: Configure logrotate for Docker logs
      copy:
        dest: /etc/logrotate.d/docker-containers
        content: |
          /var/lib/docker/containers/*/*.log {
              rotate 7
              daily
              compress
              missingok
              delaycompress
              copytruncate
          }
      tags: [docker, logrotate]

    - name: Configure logrotate for nginx
      copy:
        dest: /etc/logrotate.d/nginx
        content: |
          /var/log/nginx/*.log {
              daily
              missingok
              rotate 52
              compress
              delaycompress
              notifempty
              create 640 nginx adm
              sharedscripts
              postrotate
                  if [ -f /var/run/nginx.pid ]; then
                      kill -USR1 `cat /var/run/nginx.pid`
                  fi
              endscript
          }
      tags: [nginx, logrotate]
